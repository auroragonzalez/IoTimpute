function [zk,Vk]=krigingMPME(ck,ch,cs,zh,zs,vs,covmodel,covparam,order,options);% krigingMPME               - multi points prediction using kriging with measurement errors (Jan 1,2001)%% Combination of the krigingMP.m and krigingME.m functions.% It allows the user to realize multi-points estimations by% taking measurement errors into account. % % SYNTAX :%% [zk,Vk]=krigingMPME(ck,ch,cs,zh,zs,vs,covmodel,covparam,order,options);%% INPUT :%% ck         nk by d   matrix of coordinates for the estimation locations.%                      A line corresponds to the vector of coordinates at%                      an estimation location, so the number of columns%                      corresponds to the dimension of the space. There is%                      no restriction on the dimension of the space.% ch         nh by d   matrix of coordinates for the hard data locations,%                      with the same convention as for ck.% cs         ns by d   matrix of coordinates for the soft data locations,%                      with the same convention as for ck.% zh         nh by 1   vector of values for the hard data at the coordinates%                      specified in ch.% zs         ns by 1   vector of values for the mean of the soft data at the%                      coordinates specified in cs.% vs         ns by 1   vector of values for the variance of the soft data at%                      the coordinates specified in cs.% covmodel   string    string that contains the name of the covariance model%                      that is used for the estimation (see the MODELS directory).%                      Variogram models can not be used with this function. % covparam   1 by k    vector of values for the parameters of covmodel, according%                      to the convention for the corresponding covariance model. % order      scalar    order of the polynomial mean along the spatial axes at the%                      estimation locations. For the zero-mean case, NaN (Not-a-%                      Number) is used.% options    scalar    optional parameter that can be used if the default value%                      is not satisfactory (otherwise it can simply be omitted%                      from the input list of variables). options(1) is taking%                      the value 1 or 0 if the user wants or does not want to%                      display the order number of the location which is%                      currently processed, respectively.%% OUTPUT :%% zk        nk by 1   vector of estimated values at the estimation locations. A%                     value coded as NaN means that no estimation has been performed%                     at that location due to the lack of available data. % Vk        nk by nk  covariance matrix between the estimated values at locations%                     specified in ck.%% NOTE :%% 1- Note that in the case there are no available hard data at all,% ch and zh can be entered as the empty [ ] matrices.%% 2- All the specific conventions for specifying nested models,% multivariate or space-time cases are the same as for kriging.m.%%%%%% Initialize the parametersif nargin<10,  options(1)=0;end;noindex=~iscell(ck);       % test if there is an index for the variablesif noindex==1,  nk=size(ck,1);           % nk is the number of estimation points   nh=size(ch,1);           % nh is the number of hard data  ns=size(cs,1);           % ns is the number of soft dataelse  nk=size(ck{1},1);        % nk is the number of estimation points  nindexk=length(ck{2});  if nindexk==1,    ck{2}=ck{2}*ones(nk,1);  end;  nh=size(ch{1},1);        % nh is the number of hard data  ns=size(cs{1},1);        % ns is the number of soft dataend;if options(1)==1,  num2strnk=num2str(nk);end;zk=zeros(nk,1)*NaN;Vk=zeros(nk,nk)*NaN;k=zeros(nh+ns,nk)*NaN;%%%%%% Main loop starts hereKhh=coord2K(ch,ch,covmodel,covparam);            % built the left-hand side matrix for hard dataKss=coord2K(cs,cs,covmodel,covparam);            % built the left-hand side matrix for soft dataKhs=coord2K(ch,cs,covmodel,covparam);            % built the left-hand side matrix for hard-soft dataKss=Kss+diag(vs);                                % add the error variances on the diagonalK=[[Khh,Khs];[Khs',Kss]];                        % built the composite left-hand side matrixif noindex==1,  chs=[ch;cs];else  chs{1}=[ch{1};cs{1}];  chs{2}=[ch{2};cs{2}];end;[X,trash]=krigconstr(chs,ck,order,'left');        % build the constraint matricesnx=size(X,2);Kadd=[[K,X];[X',zeros(nx)]];K0=coord2K(ck,ck,covmodel,covparam);index=findpairs(ck,cs);for i=1:size(index,1),  K0(i,i)=K0(i,i)+vs(index(i,2));end;for i=1:nk,  if noindex==1,    ck0=ck(i,:);  else    ck0={ck{1}(i,:),ck{2}(i)};  end;  kh=coord2K(ch,ck0,covmodel,covparam);          % built the right-hand side vector for hard data  ks=coord2K(cs,ck0,covmodel,covparam);          % built the right-hand side vector for soft data  k(:,i)=[kh;ks];                                % built the composite right-hand side matrix  [trash,x]=krigconstr(chs,ck0,order,'right');   % build the constraint matrix at estimation point  kadd=[k(:,i);x];  lam=Kadd\kadd;  lam=lam(1:(nh+ns));  L(:,i)=lam;  zk(i)=lam'*[zh;zs];  if options(1)==1,    disp([num2str(i),'/',num2strnk]);  end;end;L=[eye(nk),-L'];                                 % compute the kriging covariance matrixVk=L*[[K0,k'];[k,K]]*L';