function [zh]=simuseqcond(ch,ch0,zh0,model,param,nhmax,dmax,order,options);% simuseqcond               - conditional simulation by sequential method (Jan 1,2001)%% Generate conditional simulations using the sequential% simulation method, where the conditioning values are% hard data. The simuseqcond.m function is based on the% use of the kriging.m function. To the opposite of the% simuseq.m function, this function allows the user to% use both variogram and covariance models. It is also% possible to specify the order of a polynomial mean, so% hard data do not have to be necessarily zero mean% distributed. Simulated values are Gaussian distributed. %% SYNTAX :%% [zh]=simuseqcond(ch,ch0,zh0,model,param,nhmax,dmax,order,options);%% INPUT :%% ch         nh by d   matrix of coordinates for the locations%                      where hard data have to be simulated. A%                      line corresponds to the vector of coordinates%                      at a simulation location, so the number of%                      columns corresponds to the dimension of the%                      space. There is no restriction on the dimension%                      of the space.% ch0        nh0 by d  matrix of coordinates for the hard conditioning%                      values, with the same convention as for ch.% zh0        nh0 by 1  vector of the hard conditioning values at the%                      coordinates specified in ch0.% model      string    that contains the name of the variogram or the %                      covariance model which is used for the simulation%                      (see the MODELS directory).% param      1 by k    vector of values for the parameters of model,%                      according to the convention for the corresponding%                      variogram or covariance model.% nhmax      scalar    maximum number of previously simulated hard data%                      values that are considered for the simulation at%                      each new location in the sequence. % dmax       scalar    maximum distance between a simulation location and%                      conditioning or previously visited simulation locations.%                      All locations separated by a distance smaller than dmax%                      from a simulation location will be included in the%                      simulation process for that location, whereas other%                      locations are neglected. When there are no locations%                      in the local neighbourhood, dmax is repeatidly increased%                      until there is at least one value in the neighbourhood.% order      scalar    order of the polynomial mean along the spatial axes at%                      the simulation locations. For the zero-mean case, NaN%                      (Not-a-Number) is used. Note that order=NaN can only be%                      used with covariance models and not with variogram models.% options    1 by 2    vector of optional parameters that can be used if default%                      values are not satisfactory (otherwise this vector can%                      simply be omitted from the input list of variables), where :%                      options(1)=1 for displaying the simulation location%                      currently processed (default value is 0),%                      options(2)=1 for a random selection of the visited simulation%                      locations in the sequence (default value is 1).%% OUTPUT :%% zh         nh by 1   vector of simulated Gaussian distributed hard values at the%                      coordinates specified in ch. Depending on the choice of%                      order, the values are not necessarily zero mean distributed.%% NOTE :%% All the specific conventions for specifying nested models, multivariate% or space-time cases are the same as for kriging.m.%%%%% Error messageindex=iscell(ch);          % test if there is an index for the variablesif index==1,  nh=size(ch{1},1);        % nh is the number of simulation points  nindexh=length(ch{2});  if nindexh==1,    ch{2}=ch{2}*ones(nh,1);  end;end;index=findpairs(ch,ch0);if ~isempty(index),  error('ch and ch0 cannot contain identical coordinates');end;%%%%% Initialize the parametersif nargin<9,  options(1)=0;  options(2)=1;end;isarray=iscell(ch);if ~isarray,  nh=size(ch,1);  nh0=size(ch0,1);else  nh=length(ch{2});  nh0=length(ch0{2});end;if options(1)==1,  num2strnh=num2str(nh);end;if options(2)==1,  index=randperm(nh);  if ~isarray,    ch=ch(index,:);  else    ch{1}=ch{1}(index,:);    ch{2}=ch{2}(index);  end;end;chtemp=ch0;zhtemp=zh0;for i=1:nh,   if ~isarray,    ck=ch(i,:);  else    ck={ch{1}(i,:),ch{2}(i)};  end;  zk=NaN;  dmaxiter=0;  while isnan(zk),    dmaxiter=dmaxiter+dmax;    [zk,vk]=kriging(ck,chtemp,zhtemp,model,param,nhmax,dmaxiter,order);  end;  zhtemp(i+nh0,1)=randn*sqrt(vk)+zk;  if ~isarray,    chtemp(i+nh0,:)=ck;  else    chtemp{1}(i+nh0,:)=ck{1};    chtemp{2}(i+nh0,1)=ck{2};  end;  if options(1)==1,    disp([num2str(i),'/',num2strnh]);  end;end;zh=zhtemp(nh0+1:nh+nh0);if options(2)==1,  [ignore,index]=sort(index);  zh=zh(index);end;