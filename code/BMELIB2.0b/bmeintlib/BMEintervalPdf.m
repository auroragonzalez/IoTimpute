function [z,pdf,info]=BMEintervalPdf(z,ck,ch,cs,zh,a,b,covmodel,covparam,nhmax,nsmax,dmax,order,options);% BMEintervalPdf            - BME pdf prediction with interval data (Jan 1,2001)%% Compute at a single estimation location the complete posterior% probability distribution function using both hard and interval% soft data. The function is closely related to the BMEintervalMode.m% function, but the complete distribution is provided at the% estimation location, instead of merely the mode of this distribution.%% SYNTAX :%% [z,pdf,info]=BMEintervalPdf(z,ck,ch,cs,zh,a,b,covmodel,covparam,nhmax,nsmax,dmax,order,options);%% INPUT :%% z          nz by 1     vector of values sorted in ascending order for which%                        the distribution must be computed. It is recommended%                        to have a finely discretized set of values, so that%                        the distribution can be computed on a fine scale.% ck         1  by d     vector of coordinates for the estimation location,%                        where d is the dimension of the space. For doing%                        computation at different estimation locations, the%                        function can be invoked in a loop so that a new ck%                        vector and probabilistic soft data can be used.% ch         nh by d     matrix of coordinates for the hard data locations,%                        with the same convention as for ck.% cs         ns by d     matrix of coordinates for the soft data locations,%                        with the same convention as for ck.% zh         nh by 1     vector of values for the hard data at the coordinates%                        specified in ch.% a          ns by 1     vector of values for the lower bound of the intervals%                        at the coordinates specified in cs.% b          ns by 1     vector of values for the upper bound of the intervals%                        at the coordinates specified in cs.% covmodel   string      string that contains the name of the covariance model%                        that is used for the estimation (see the MODELS directory).%                        Variogram models are not available for this function.% covparam   1 by k      vector of values for the parameters of covmodel, according%                        to the convention for the corresponding covariance model.% nhmax      scalar      maximum number of hard data values that are considered%                        for the estimation at the locations specified in ck.% nsmax      scalar      maximum number of soft data values that are considered for%                        the estimation at the locations specified in ck. As the%                        computation time is exponentially increasing with nsmax,%                        it is not advised to use more than few soft data locations.%                        In any case, nsmax should be lower than 20 in order to%                        avoid numerical computation problems.% dmax       scalar      maximum distance between an estimation location and%                        existing hard/soft data locations. All hard/soft data%                        locations separated by a distance smaller than dmax from an%                        estimation location will be included in the estimation process%                        for that location, whereas other data locations are neglected.% order      scalar      order of the polynomial drift along the spatial axes at the%                        estimation locations. For the zero-mean case, NaN (Not-a-Number)%                        is used.% options    1 by 4      vector of optional parameters that can be used if default values%                        are not satisfactory (otherwise this vector can simply be omitted%                        from the input list of variables), where :%                        options(3) specifies the maximum number of evaluation that can be%                        done by the FORTRAN77 subroutines for the integrals (default value%                        is 50 000 ; this value should be increased if a warning message%                        appears on the screen during the computation). options(4) specifies%                        the maximum admissible relative error on the estimation of these%                        integrals (default value is 1e-4).%                        The values for options(1) and options(2) are not used.%% OUTPUT :%% z          nzout by 1  possibly modified column vector of values for which the posterior%                        distribution has been computed. The output z vector differs from%                        the input z vector when there is an interval data at the estimation%                        location. In that case, the bounds of the intervals are added to%                        the original z vector.% pdf        nzout by 1  vector of values for the probability distribution function computed%                        at the z values.% info       nzout by 1  vector for information about the computation of estimated values.%                        The different possible values are the same as for info in%                        BMEintervalMode.m, except for info=2. For info=5, the output pdf%                        variable is a uniform distribution with bounds equal to those of%                        the interval specified at the estimation location.%% NOTE :%% 1- Note that in the case there are no available hard data at all,% ch and zh can be entered as the empty [ ] matrices.%% 2-  All the specific conventions for specifying nested models,% multivariate or space-time cases are the same as for BMEprobaMoments.m.%%%%%% Error messagesif sum(nsmax)>20,  error('sum(nsmax) must not exceed 20');end;%%%%%% Initialize the parametersglobal INFOINTEG      % information message from the Fortran integration subroutineif nargin<14,         % initialize options with default values if not provided as input  options(3)=50000;  options(4)=1e-4;end;%%%%%% Select the local neighbourhood[chlocal,zhlocal,dh,sumnhlocal]=neighbours(ck,ch,zh,nhmax,dmax);[cslocal,ablocal,ds,sumnslocal]=neighbours(ck,cs,[a b],nsmax,dmax);if ~isempty(ablocal),  alocal=ablocal(:,1);blocal=ablocal(:,2);else  alocal=[];blocal=[];end;%%%%%% Test if there is a hard data at estimation pointiscomputed=0;  [index]=findpairs(ck,chlocal);                   % test if there is a hard data at estimation pointif ~isempty(index),    z=zhlocal(index(2));                           % return the hard data value as the z vector  pdf=Inf;                                       % set the corresponding pdf value to +Inf  info=4;                                        % set the value of info to 4  iscomputed=1;                                  % specify that the pdf has been computedend;%%%%%% Test if there is a soft data at estimation pointisduplicate=0;[index]=findpairs(ck,cslocal);if ~isempty(index),                            % split the soft data into two sets  [csest,cslocal,abest,ablocal]=split(cslocal,[alocal blocal],index(2));  alocal=ablocal(:,1);  blocal=ablocal(:,2);  aest=abest(:,1);  best=abest(:,2);  indexin=find(z>aest && z<best);               % find the z values inside the interval [aest,best]  z=[aest;z(indexin);best];                    % select a subset of z and add the bounds of the interval  sumnslocal=sumnslocal-1;                     % decrease the number of soft data by 1  isduplicate=1;                               % specify that there is a soft data at estimation pointend;%%%%%% Returns NaN or the uniform pdf when (sumnhlocal=0)&&(sumnslocal==0)&&(iscomputed==0)if (sumnhlocal==0)&&(sumnslocal==0)&&(iscomputed==0),  if isduplicate==1,    pdf=uniformpdf(z,[aest,best]);    info=ones(size(z))*5;  else    nz=length(z);    pdf=ones(nz,1)*NaN;    info=ones(nz,1)*NaN;  end;end;%%%%%% Returns the kriging pdf when nslocal==0if (sumnhlocal>0)&&(sumnslocal==0)&&(iscomputed==0), % test if there are no soft data  K=coord2K(chlocal,chlocal,covmodel,covparam);    % built the left-hand side  k=coord2K(chlocal,ck,covmodel,covparam);         % built the right-hand side  [X,x]=krigconstr(chlocal,ck,order);              % built the constraints matrix and vector  nx=size(X,2);  Kadd=[[K,X];[X',zeros(nx)]];  kadd=[k;x];  lam=Kadd\kadd;                                   % compute the kriging weights lam  lam=lam(1:sumnhlocal);                           % remove the Lagrangians from the solution  lamt=lam';  zk=lamt*zhlocal;                                 % compute the kriging estimate zk(i)  vk=K(1,1)-2*lamt*k+lamt*K*lam;                   % compute the kriging variance vk(i) for covariance  pdf=gausspdf(z,[zk vk]);                         % compute the value of the Gaussian pdf  info=ones(size(z))*3;                            % set the value of info to 3end;%%%%%% Returns the BME pdf when nslocal>0if (sumnslocal>0)&&(iscomputed==0),                % test if there is at least one soft data   pdf=zeros(size(z))*NaN;                         % initialize the pdf values  info=zeros(size(z))*NaN;                        % initialize the info values  Kkk=coord2K(ck,ck,covmodel,covparam);           % compute variance for estimation point  Khh=coord2K(chlocal,chlocal,covmodel,covparam); % compute covariance matrix for hard data  Kss=coord2K(cslocal,cslocal,covmodel,covparam); % compute covariance matrix for soft data  Kkh=coord2K(ck,chlocal,covmodel,covparam);      % compute cross-covariance vector estimation/hard data  Kks=coord2K(ck,cslocal,covmodel,covparam);      % compute cross-covariance vector estimation/soft data  Ksh=coord2K(cslocal,chlocal,covmodel,covparam); % compute cross-covariance matrix soft/hard data  Kkhkh=[[Kkk,Kkh];[Kkh',Khh]];                   % build estimation+hard data covariance matrix  Kskh=[Kks',Ksh];                                % build cross-covariance matrix soft/estimation+hard data  mslocal=(alocal+blocal)/2;                      % compute the mean assuming uniform distribution  vslocal=((blocal-alocal).^2)/12;                % compute the variance assuming uniform distribution  [mkest,mhest,msest,vkest]=localmeanBME(ck,chlocal,cslocal,zhlocal,mslocal,vslocal,Khh,Ksh,Kss,order);  z=z-mkest;                                      % substract the mean from the values to be processed  zhlocal=zhlocal-mhest;                          % substract the mean from the hard data  alocal=alocal-msest;                            % substract the mean from the soft data  blocal=blocal-msest;  if sumnhlocal==0,                               % if no hard data use the soft covariance     [fden]=intBMEinterval([],alocal,blocal,[],Kss,options);  else                                            % else use the conditional soft covariance    invKhh=inv(Khh);    KshinvKhh=Ksh*invKhh;    cstden=1/(((2*pi)^(sumnhlocal/2))*sqrt(det(Khh)));    [Pden]=intBMEinterval(zhlocal,alocal,blocal,KshinvKhh,Kss-KshinvKhh*Ksh',options);    fden=cstden*exp(-0.5*zhlocal'*invKhh*zhlocal)*Pden;  end;  if fden==0,                                     % if denominator=0, set pdf values to 0     pdf=zeros(size(z));   else                                            % else compute the numerator values    cstnum=1/(((2*pi)^((sumnhlocal+1)/2))*sqrt(det(Kkhkh)));    invKkhkh=inv(Kkhkh);    KskhinvKkhkh=Kskh*invKkhkh;    for i=1:length(z),      [Pnum]=intBMEinterval([z(i);zhlocal],alocal,blocal,KskhinvKkhkh,Kss-KskhinvKkhkh*Kskh',options);      fnum=cstnum*exp(-0.5*[z(i);zhlocal]'*invKkhkh*[z(i);zhlocal])*Pnum;      pdf(i)=fnum/fden;      if INFOINTEG==0,info(i)=0;end;      if INFOINTEG==1,info(i)=1;end;    end;  end;  z=z+mkest;end;%%%%%% Reset the pdf values in the interval [aest,best] if neededif isduplicate==1,                          % if there is a soft data at estimation point  cst=trapezint(z,pdf,aest,best);           % integrate the function over [aest,best]  pdf=pdf/cst;                              % normalize the pdf values by the integral  z=[aest;z;best];                          % add the bounds of the interval to the z vector  pdf=[0;pdf;0];                            % add 0 as value of the pdf at the bounds  ninfo=length(info);                       % compute the length of the info vector  info=[info(1);info;info(ninfo)];          % add first and last info values at the boundsend;