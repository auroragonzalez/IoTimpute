function [zk,info]=BMEintervalMode3(ck,ch,cs,zh,a,b,covmodel,covparam,nhmax,nsmax,dmax,order,options);% BMEintervalMode           - BME mode prediction with interval data (Jan 1,2001)%% Compute at a set of estimation locations the mode of the% posterior probability distribution function using both% hard and interval soft data, where the mode is the most% likely value.%% SYNTAX :%% [zk,info]=BMEintervalMode(ck,ch,cs,zh,a,b,covmodel,covparam,nhmax,nsmax,dmax,order,options);%% INPUT :%% ck         nk by d      matrix of coordinates for the estimation locations.%                         A line corresponds to the vector of coordinates at%                         an estimation location, so the number of columns%                         corresponds to the dimension of the space. There is%                         no restriction on the dimension of the space.% ch         nh by d      matrix of coordinates for the hard data locations,%                         with the same convention as for ck.% cs         ns by d      matrix of coordinates for the soft data locations,%                         with the same convention as for ck.% zh         nh by 1      vector of values for the hard data at the coordinates%                         specified in ch.% a          ns by 1      vector of values for the lower bound of the intervals%                         at the coordinates specified in cs.% b          ns by 1      vector of values for the upper bound of the intervals%                         at the coordinates specified in cs.% covmodel   string       string that contains the name of the covariance model%                         that is used for the estimation (see the modelslib directory).%                         Variogram models are not available for this function.% covparam   1 by k       vector of values for the parameters of covmodel, according%                         to the convention for the corresponding covariance model.% nhmax      scalar       maximum number of hard data values that are considered%                         for the estimation at the locations specified in ck.% nsmax      scalar       maximum number of soft data values that are considered for%                         the estimation at the locations specified in ck. As the%                         computation time is exponentially increasing with nsmax,%                         it is not advised to use more than few soft data locations.%                         In any case, nsmax should be lower than 20 in order to%                         avoid numerical computation problems.% dmax       scalar       maximum distance between an estimation location and%                         existing hard/soft data locations. All hard/soft data%                         locations separated by a distance smaller than dmax from an%                         estimation location will be included in the estimation process%                         for that location, whereas other data locations are neglected.% order      scalar       order of the polynomial drift along the spatial axes at the%                         estimation locations. For the zero-mean case, NaN (Not-a-Number)%                         is used.% options    1 by 1 or 14 vector of optional parameters that can be used if default%                         values are not satisfactory (otherwise this vector can simply be%                         omitted from the input list of variables), where :%                         options(1), options(2) and options(14) are values used by the%                         fminbnd.m MATLAB optimization routine that finds the mode of the%                         probability distribution function (default values are the same%                         as for fminbnd.m),%                         options(3) specifies the maximum number of evaluation that can%                         be done by the FORTRAN77 subroutines for the integrals (default%                         value is 50 000 ; this value should be increased if a warning%                         message appears on the screen during the computation),%                         options(4) specifies the maximum admissible relative error on the%                         estimation of these integrals (default value is 1e-4). The values%                         for options(5) to options(13) are not used.%% OUTPUT :%% zk         nk by 1      vector of estimated values at the estimation locations. A value%                         coded as NaN means that no estimation has been performed at that%                         location due to the lack of available data.% info       nk by 1      vector for information about the computation of estimated values.%                         Different possible values are :%                         info=NaN if there is no computation at all (no hard and soft data%                         are available around or at the estimation location),%                         info=0 when computation is made using BME with at least 1 soft data,%                         info=1 when the estimation is dubious due to an integration error%                         above the tolerance specified in options(4),%                         info=2 when the estimation is dubious as the result did not converge%                         within the maximum number of iterations specified in options(14),%                         info=3 when the computation is made using kriging with no soft data,%                         info=4 when there is a hard data value at the estimation location,%                         info=5 when there is only an interval at the estimation location%                         (the output zk value is then the middle of this interval).%% NOTE :%% 1- Note that in the case there are no available hard data at all,% ch and zh can be entered as the empty [ ] matrices.%% 2-  All the specific conventions for specifying nested models,% multivariate or space-time cases are the same as for BMEprobaMoments.m.%%%%%% Error messagesif sum(nsmax)>20,  error('sum(nsmax) must not exceed 20');end;%%%%%% Initialize the parametersglobal INFOINTEG      % information message from the Fortran subroutineif nargin<13,         % initialize options with default values  options(1)=0;  options1=0;  options(2)=1e-4;  options(14)=500;  options(3)=50000;  options(4)=1e-4;else  options1=options(1);  options(1)=0;end;if length(options)<2 || ~options(2)  options(2)=1e-4;end  TolX=options(2);if length(options)<14 || ~options(14)  options(14)=500;end  MaxFunEvals=options(14);fminbndoptions = optimset('Display','off','TolX',TolX,'MaxFunEvals',MaxFunEvals);noindex=~iscell(ck);       % test if there is an index for the variablesif noindex==1,  nk=size(ck,1);           % nk is the number of estimation points  nh=size(ch,1);           % nh is the number of hard data  ns=size(cs,1);           % ns is the number of soft dataelse  nk=size(ck{1},1);  nindexk=length(ck{2});  if nindexk==1,    ck{2}=ck{2}*ones(nk,1);  end;  nh=size(ch{1},1);  ns=size(cs{1},1);end;if options1==1,  num2strnk=num2str(nk);end;zk=zeros(nk,1)*NaN;info=zeros(nk,1)*NaN;%%%%%% Main loop starts herefor i=1:nk,  if noindex==1,    ck0=ck(i,:);   else    ck0={ck{1}(i,:),ck{2}(i)};  end;  %%aurorax  ch0 = ch{i};  zh0 = zh{i}'; % cs0 = cs{i}; % a0 = a{i}'; % b0 = b{i}';      %%%%%% Select the local neighbourhood for all variables  [chlocal,zhlocal,dh,sumnhlocal]=neighbours(ck0,ch0,zh0,nhmax,dmax);  %aurorax ch-->ch0, zh-->zh0 % [cslocal,ablocal,ds,sumnslocal]=neighbours(ck0,cs0,[a0 b0],nsmax,dmax); %aurorax cs-->cs0, a-->a0, b-->b0    [cslocal,ablocal,ds,sumnslocal]=neighbours(ck0,cs,[a b],nsmax,dmax); %aurorax cs-->cs0, a-->a0, b-->b0    if ~isempty(ablocal),    alocal=ablocal(:,1);blocal=ablocal(:,2);  else    alocal=[];blocal=[];  end;  %%%%%% Test if there is a hard data at estimation point  iscomputed=0;  [index]=findpairs(ck0,chlocal);  if ~isempty(index),                            % if there is a hard data at estimation point,    zk(i)=zhlocal(index(2));                     % return the hard data value as the estimate    info(i)=4;                                   % set the value of info to 4     iscomputed=1;                                % specify that the value has been computed  end;  %%%%%% Test if there is a soft data at estimation point  isduplicate=0;  [index]=findpairs(ck0,cslocal);                 if ~isempty(index),                [csest,cslocal,abest,ablocal]=split(cslocal,[alocal blocal],index(2));    alocal=ablocal(:,1);    blocal=ablocal(:,2);    aest=abest(:,1);    best=abest(:,2);    sumnslocal=sumnslocal-1;    isduplicate=1;    end;  %%%%%% Returns NaN or the middle of the interval when (sumnhlocal=0)&&(sumnslocal==0)&&(iscomputed==0)  if (sumnhlocal==0)&&(sumnslocal==0)&&(iscomputed==0),    if isduplicate==1,      zk(i)=(aest+best)/2;      info(i)=5;    else      zk(i)=NaN;        info(i)=NaN;    end;  end;  %%%%%% Returns the cokriging estimate when sumnslocal==0  if (sumnhlocal>0)&&(sumnslocal==0)&&(iscomputed==0),% test if there are no soft data    K=coord2K(chlocal,chlocal,covmodel,covparam);   % built the left-hand side matrix    k=coord2K(chlocal,ck0,covmodel,covparam);       % built the right-hand side vector    [X,x]=krigconstr(chlocal,ck0,order);            % built the constraints matrix and vector    nx=size(X,2);    Kadd=[[K,X];[X',zeros(nx)]];    kadd=[k;x];    lam=Kadd\kadd;                                  % compute the kriging weights lam    lam=lam(1:sumnhlocal);                          % remove the Lagrangians from the solution    lamt=lam';    zk(i)=lamt*zhlocal;                             % compute the kriging estimate zk(i)    info(i)=3;  end;  if isduplicate==1,    if zk(i)<aest,zk(i)=aest;end;    if zk(i)>best,zk(i)=best;end;  end;  %%%%%% Returns the BME estimate when sumnslocal>0  if (sumnslocal>0)&&(iscomputed==0),    Kkk=coord2K(ck0,ck0,covmodel,covparam);         % compute variance for estimation point    Khh=coord2K(chlocal,chlocal,covmodel,covparam); % compute covariance matrix for hard data    Kss=coord2K(cslocal,cslocal,covmodel,covparam); % compute covariance matrix for soft data    Kkh=coord2K(ck0,chlocal,covmodel,covparam);     % compute cross-covariance vector estimation/hard data    Kks=coord2K(ck0,cslocal,covmodel,covparam);     % compute cross-covariance vector estimation/soft data    Ksh=coord2K(cslocal,chlocal,covmodel,covparam); % compute cross-covariance matrix soft/hard data    Kkhkh=[[Kkk,Kkh];[Kkh',Khh]];                   % build estimation+hard data covariance matrix    Kskh=[Kks',Ksh];                                % build cross-covariance matrix soft/estimation+hard data    invKkhkh=inv(Kkhkh);    KskhinvKkhkh=Kskh*invKkhkh;    Kssifkh=Kss-KskhinvKkhkh*Kskh';                 % compute the conditional covariance matrix    mslocal=(alocal+blocal)/2;                      % compute the mean assuming uniform distribution    vslocal=((blocal-alocal).^2)/12;                % compute the variance assuming uniform distribution    [mkest,mhest,msest]=localmeanBME(ck0,chlocal,cslocal,zhlocal,mslocal,vslocal,Khh,Ksh,Kss,order);    zhlocal=zhlocal-mhest;                          % substract the mean from the hard data    alocal=alocal-msest;                            % substract the mean from the soft data    blocal=blocal-msest;    if isduplicate==1,      zkmin=aest-mkest;      zkmax=best-mkest;    else      zkmin=min([zhlocal;alocal;0]);                % initialize the minimum and maximum guess      zkmax=max([zhlocal;blocal;0]);                % values to be used by fminbnd    end;    [zk(i),FVAL,EXITFLAG,OUTPUT]=fminbnd(@fminBMEintervalMode,zkmin,zkmax,fminbndoptions,...      zhlocal,alocal,blocal,invKkhkh,KskhinvKkhkh,Kssifkh,options);    options(10)=OUTPUT.funcCount;        zk(i)=zk(i)+mkest;                                 % add the mean to the mode estimate    %%%%%% Select the appropriate info value    if options(10)>=options(14),       info(i)=2;    else      if INFOINTEG==0,info(i)=0;end;      if INFOINTEG==1,info(i)=1;end    end;  end;  if options1==1,    disp([num2str(i),'/',num2strnk]);  end;end;