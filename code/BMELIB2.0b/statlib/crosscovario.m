function [d,c,o]=crosscovario(c1,c2,z1,z2,cl,method,options);% crosscovario              - single cross covariance function estimation (Jan 1,2001)%% Single covariance function or cross covariance function% estimation. To the opposite of the covario.m function,% crosscovario.m is is able to deal with the case where the% values of the two variables are given for two sets of% partially or totally different locations. %% SYNTAX :%% [d,c,o]=crosscovario(c1,c2,z1,z2,cl,method,options);%% INPUT : %% c1        n1 by d      matrix of coordinates for the locations where the%                        values of the first variable are known. A line%                        corresponds to the vector of coordinates at a location,%                        so the number of columns is equal to the dimension of%                        the space. There is no restriction on the dimension of%                        the space.% c2        n2 by d      matrix of coordinates for the locations where the values%                        of the second variable are known, using the same conventions%                        as for c1.% z1        n1 by 1      column vector of values for the first variable at the%                        coordinates specified in c1.% z2        n2 by 1      column vector of values for the second variable at the%                        coordinates specified in c2.% cl        nc+1 by 1    vector giving the limits of the distance classes that are%                        used for estimating the cross covariance. The distance classes%                        are open on the left and closed on the right. The lower limit%                        for the first class is >=0.% method    string       that contains the name of the method used for computing%                        the distances between pairs of locations. method='kron'%                        uses a Kronecker product, whereas method='loop' uses a loop%                        over the locations. Using the Kronecker product is faster%                        for a small number of locations but may suffer from memory%                        size limitations depending on the memory available as its%                        requires the storage of a distance matrix. The loop method%                        may be used whatever the number of data locations and must be%                        used if an Out of Memory error message is generated. Both%                        methods yield exactly the same estimates.% options  1 by 1,3 or 4 vector of optional parameters that can be used if default%                        values are not satisfactory (otherwise this vector can simply%                        be omitted from the input list of variables), where :%                        options(1) displays the estimated cross covariance if the value%                        is set to one (default value is 0),%                        options(2) and options(3) are the minimum and maximum values%                        for the angles to be considered, using the same conventions as%                        for the pairsplot.m function. Angles can only be specified for%                        planar coordinates, i.e. when the number of columns in c1 and%                        c2 is equal to two,%                        options(4) is equal to 0 if the mean is null and equal to 1 if%                        the mean is constant but non null (default value is 1).%% OUTPUT :%% d        nc by 1       vector giving the sorted values of the mean distance separating%                        the pairs of points that belong to the same distance class. % c        nc by 1       vector of estimated covariance or cross covariance function%                        values (if z1 and z2 are identical, the function computes the%                        covariance function).% o        nc by 1       vector giving the number of pairs of points that belong to the %                        corresponding distance classes.%% NOTE :%% Note that using crosscovario(c1,c2,z1,z2,cl,method) yields the% same result as using crosscovario(c2,c1,z2,z1,cl,method) both for% method='kron'and method='loop'.%%%%%% Initialize the parametersif ~ischar(method),  error('method should be a char string');end;cl=sort(cl);if cl(1)<0,  error('Minimum class distance must be >=0');end;n1=size(c1,1);n2=size(c2,1);nc=length(cl)-1;minim=cl(1);maxim=cl(nc+1);if nargin==6,  options(1)=0;  noptions=1;else  noptions=length(options);end;if noptions>=3,  a=options(2)*2*pi/360;  b=options(3)*2*pi/360;  if (size(c1,2)~=2 & size(c2,2)~=2),    error('Angle limits are specified only for planar coordinates');  end;  if (a==b)|(min([a,b])<-pi/2)|(max([a,b])>pi/2),    error('Angle limits must be different and between or equal to -90 and 90');  end;end;%%%%%% Substract the meansif noptions==4,  options4=options(4);else   options4=1;end;if options4==1,  z1=z1-mean(z1);  z2=z2-mean(z2);end;if strcmp(method,'kron')==1,   %%%%% Uses a Kronecker product for computing distances  %%% Compute the distances  unit1=ones(n1,1);  unit2=ones(n2,1);  dc=kron(unit1,c2)-kron(c1,unit2);  if size(dc,2)==1,    dist=abs(dc);  else    dist=sqrt(sum((dc.^2)')');  end;  %%% Compute the angles  if noptions>=3,    finddc1null=find(dc(:,1)==0);    finddc1notnull=find(dc(:,1)~=0);    ang=zeros(size(dc,1),1);    ang(finddc1null)=(pi/2)*sign(dc(finddc1null,2));    ang(finddc1notnull)=atan(dc(finddc1notnull,2)./dc(finddc1notnull,1));  end;  %%% Select couples for appropriate distances and angles  cond=(dist>max([0,minim]))&(dist<=maxim);  if noptions>=3,    conda=(ang>a);    condb=(ang<=b);    if a<b,      cond=cond & (conda & condb);    else      cond=cond & (conda | condb);    end;  end;  dist=dist(cond);  m=length(dist);  if m==0,    error('No couples of values within the specified classes');  end;  %%% Compute the cross-covariogram  isclass=cell(nc);  d=zeros(nc,1)*NaN;  o=zeros(nc,1);  for k=1:nc,    isclass{k}=find((dist>cl(k))&(dist<=cl(k+1)));    o(k)=length(isclass{k})/2;    if o(k)~=0,      d(k)=sum(dist(isclass{k}))/(2*o(k));    end;  end;  product=kron(unit1,z2).*kron(z1,unit2);  product=product(cond);  c=zeros(nc,1)*NaN;  for k=1:nc,    if o(k)~=0,      c(k)=sum(product(isclass{k}))/(2*o(k));    end;  end;else                      %%%%% Uses a loop over the data for computing distances  d=zeros(nc,1);  o=zeros(nc,1);  c=zeros(nc,1);  for i=1:n1,    for j=1:n2,      dist=sqrt(sum((c1(i,:)-c2(j,:)).^2));      cond=(dist>max([0 minim]))&(dist<=maxim);      if noptions==3,        dc=c1(i,1:2)-c2(j,1:2);        if dc(1)==0,          ang=(pi/2)*sign(dc(2));        else          ang=atan(dc(2)/dc(1));        end;        conda=(ang>a);        condb=(ang<=b);        if a<b,          cond=cond & (conda & condb);        else          cond=cond & (conda | condb);        end;      end;      if cond==1,        index=sum(dist>cl);        if (index>=1) & (index<=nc),          d(index)=d(index)+dist;          o(index)=o(index)+1;          c(index)=c(index)+z1(i)*z2(j);        end;      end;    end;  end;  for i=1:nc,    if o(i)==0,      d(i)=NaN;      c(i)=NaN;    else      d(i)=d(i)/o(i);      c(i)=c(i)/o(i);      o(i)=o(i)/2;    end;  end;end;%%%%%% display the computed cross-covariogram if options(1)=1if options(1)==1,  test=(ishold==1);  minc=min(c(~isnan(c)));  maxc=max(c(~isnan(c)));  maxd=max(d(~isnan(d)));  plot(d,c,'.');hold on;  text(d,c,num2str(o),'FontSize',8);  set(gca,'FontSize',6);  axis([0 maxd min([0;-1.1*sign(minc)*minc]) max([0;1.1*sign(maxc)*maxc])]);  plot([0 maxd],[0 0],':');  xlabel('Distance','FontSize',8);  ylabel('Cross-covariogram','FontSize',8);  if test==0,    hold off;  end;end;%%%%%% Check if there are no NaNif length(find(isnan(d))),  disp('Warning : some distance classes do not contain pairs of points');end;