function [d,v,o]=crossvario(c1,c2,z1,z2,cl,method,options);% crossvario                - single cross variogram estimation (Jan 1,2001)%% Single variogram or cross variogram estimation. To the opposite of% the vario.m function, crossvario.m is is able to deal with the case% where the values of the two variables are given for two sets of% partially different locations. When several variograms or cross% variograms have to be computed for variables known at the same set% of locations, using vario.m is computationally more efficient than% a repeated use of crossvario.m.%% SYNTAX :%% [d,v,o]=crossvario(c1,c2,z1,z2,cl,method,options);%% INPUT : %% c1        n1 by d      matrix of coordinates for the locations where the%                        values of the first variable are known. A line%                        corresponds to the vector of coordinates at a location,%                        so the number of columns is equal to the dimension of%                        the space. There is no restriction on the dimension of%                        the space.% c2        n2 by d      matrix of coordinates for the locations where the values%                        of the second variable are known, using the same conventions%                        as for c1.% z1        n1 by 1      column vector of values for the first variable at the%                        coordinates specified in c1.% z2        n2 by 1      column vector of values for the second variable at the%                        coordinates specified in c2.% cl        nc+1 by 1    vector giving the limits of the distance classes that are%                        used for estimating the cross variogram. The distance classes%                        are open on the left and closed on the right. The lower limit%                        for the first class is >=0.% method    string       that contains the name of the method used for computing%                        the distances between pairs of locations. method='kron'%                        uses a Kronecker product, whereas method='loop' uses a loop%                        over the locations. Using the Kronecker product is faster%                        for a small number of locations but may suffer from memory%                        size limitations depending on the memory available as its%                        requires the storage of a distance matrix. The loop method%                        may be used whatever the number of data locations and must be%                        used if an Out of Memory error message is generated. Both%                        methods yield exactly the same estimates.% options   1 by 1 or 3  vector of optional parameters that can be used if default%                        values are not satisfactory (otherwise this vector can simply%                        be omitted from the input list of variables), where :%                        options(1) displays the estimated cross variogram if the value%                        is set to one (default value is 0),%                        options(2) and options(3) are the minimum and maximum values%                        for the angles to be considered, using the same conventions as%                        for the pairsplot.m function. Angles can only be specified for%                        planar coordinates, i.e. when the number of columns in c1 and%                        c2 is equal to two.%% OUTPUT :%% d         nc by 1      vector giving the sorted values of the mean distance separating%                        the pairs of points that belong to the same distance class. % v         nc by 1      vector of estimated variogram or cross variogram values (if z1%                        and z2 are identical, the function computes the variogram).% o         nc by 1      vector giving the number of pairs of points that belong to the %                        corresponding distance classes.%% NOTE :%% Note that using crossvario(c1,c2,z1,z2,cl,method) yields the same result% as using crossvario(c2,c1,z2,z1,cl,method) both for method='kron' and% method='loop'.%%%%%% Select the subset of identical coordinatesif ~ischar(method),  error('method should be a char string');end;index=findpairs(c1,c2);if isempty(index),  error('There are no identical coordinates. Cannot compute cross-variogram');end;c=c1(index(:,1),:);z1=z1(index(:,1));z2=z2(index(:,2));%%%%%% Initialize the parameterscl=sort(cl);if cl(1)<0,  error('Minimum class distance must be >=0');end;n=size(c,1);nc=length(cl)-1;minim=cl(1);maxim=cl(nc+1);if nargin==6,  options(1)=0;  noptions=1;else  noptions=length(options);end;if noptions==3,  a=options(2)*2*pi/360;  b=options(3)*2*pi/360;    if (size(c1,2)~=2 & size(c2,2)~=2),    error('Angle limits are specified only for planar coordinates');  end;  if (a==b)|(min([a,b])<-pi/2)|(max([a,b])>pi/2),    error('Angle limits must be different and between or equal to -90 and 90');  end;end;if strcmp(method,'kron')==1,   %%%%% Uses a Kronecker product for computing distances  %%% Compute the distances  unit=ones(n,1);  dc=kron(unit,c)-kron(c,unit);  if size(dc,2)==1,    dist=abs(dc);  else    dist=sqrt(sum((dc.^2)')');  end;  %%% Compute the angles  if noptions==3,    finddc1null=find(dc(:,1)==0);    finddc1notnull=find(dc(:,1)~=0);    ang=zeros(size(dc,1),1);    ang(finddc1null)=(pi/2)*sign(dc(finddc1null,2));    ang(finddc1notnull)=atan(dc(finddc1notnull,2)./dc(finddc1notnull,1));  end;  %%% Select couples for appropriate distances and angles  cond=(dist>max([0,minim]))&(dist<=maxim);  if noptions==3,    conda=(ang>a);    condb=(ang<=b);    if a<b,      cond=cond & (conda & condb);    else      cond=cond & (conda | condb);    end;  end;  dist=dist(cond);  m=length(dist);  if m==0,    error('No couples of values within the specified classes');  end;  %%% Compute the cross-variogram  isclass=cell(nc);  d=zeros(nc,1)*NaN;  o=zeros(nc,1);  for k=1:nc,    isclass{k}=find((dist>cl(k))&(dist<=cl(k+1)));    o(k)=length(isclass{k})/2;    if o(k)~=0,      d(k)=sum(dist(isclass{k}))/(2*o(k));    end;  end;  dz1=kron(unit,z1)-kron(z1,unit);  dz2=kron(unit,z2)-kron(z2,unit);  product=dz1.*dz2;  product=product(cond);  v=zeros(nc,1)*NaN;  for k=1:nc,    if o(k)~=0,      v(k)=sum(product(isclass{k}))/(4*o(k));    end;  end;else                      %%%%% Uses a loop over the data for computing distances  d=zeros(nc,1);  o=zeros(nc,1);  v=zeros(nc,1);  for i=1:n,    for j=i+1:n,      dist=sqrt(sum((c(i,:)-c(j,:)).^2));      cond=(dist>max([0 minim]))&(dist<=maxim);      if noptions==3,        dc=c(i,1:2)-c(j,1:2);        if dc(1)==0,          ang=(pi/2)*sign(dc(2));        else          ang=atan(dc(2)/dc(1));        end;        conda=(ang>a);        condb=(ang<=b);        if a<b,          cond=cond & (conda & condb);        else          cond=cond & (conda | condb);        end;      end;      if cond==1,        index=sum(dist>cl);        if (index>=1) & (index<=nc),          d(index)=d(index)+dist;          o(index)=o(index)+1;          v(index)=v(index)+(z1(i)-z1(j))*(z2(i)-z2(j));        end;      end;    end;  end;  for i=1:nc,    if o(i)==0,      d(i)=NaN;      v(i)=NaN;    else      d(i)=d(i)/o(i);      v(i)=v(i)/(2*o(i));    end;  end;end;%%%%%% display the computed cross-variogram if options(1)=1if options(1)==1,  test=(ishold==1);  minv=min(v(~isnan(v)));  maxv=max(v(~isnan(v)));  maxd=max(d(~isnan(d)));  plot(d,v,'.');hold on;  text(d,v,num2str(o),'FontSize',8);  set(gca,'FontSize',6);  axis([0 maxd min([0;-1.1*sign(minv)*minv]) max([0;1.1*sign(maxv)*maxv])]);  plot([0 maxd],[0 0],':');  xlabel('Distance','FontSize',8);  ylabel('Cross-variogram','FontSize',8);  if test==0,    hold off;  end;end;%%%%%% Check if there are no NaNif length(find(isnan(d)))~=0,  disp('Warning : some distance classes do not contain pairs of points');end;